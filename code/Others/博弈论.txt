两堆石子 一次可以取其中一堆 或者两堆同时取相同的数目
1 1 2
2 3 5
3 4 7
4 6 10... 首项A(N)=TRUNC(N(SQRT(5)+1/2))

nim 
n阶nim   
在线求nim方案 （nlog（xi））维护最高位在第K位的所有数字（双向链表）

一排石子堆 每次只能从一堆取任意个放到它右边的那堆里面 不能操作者输 
解法 隔位异或 原理用NIM的原理套用即可。 很多题目都是源自这个模型。


许多博弈游戏本质是动态规划 考察单调性（可以通过研究问题本身性质获得，也可以打表找规律）
状态单调：最好能得到两维关系的状态 有一维是单调的（k倍动态减法问题） 或者只有一个特殊值的（许多堆石子，只能取最边上两堆，浙江省选二试）。
决策单调：（k倍动态减法问题）一旦这个点在决策中不起作用 以后的决策中这个也不会起作用 np
【记忆化搜索？】单调是博弈的难点也是非常巧妙的重点。


SG函数适用的游戏：无法做出决策者输
若游戏可以分成若干个小游戏 每次选一个游戏操作 那么这个大游戏的SG值为所有小游戏的SG异或和
SG=MEX(此游戏状态可以操作到的所有子状态)
子游戏有时候不一定很容易划分 有些看似不能分解成子游戏 事实上可以 例子：
浙江09省选一试 game 以及 翻硬币问题 （每次操作非常随意，但事实上均可以分解成每个硬币单独游戏的情况再求异或和）


SG较NP的优势是可以求游戏的和 不少题目还是无法用NP或SG去做 还是自己摸索必胜策略以及必败态(打出SG表找规律)


Anti-SG游戏：做最后一步决策者输
对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束，则先手必胜当且仅当：
（1）游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1；
（2）游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。

Every-SG 游戏规定，对于还没有结束的单一游戏，游戏者必须
对该游戏进行一步决策；
Every-SG 游戏的其他规则与普通SG 游戏相同

            0     v是终止状态
step(v)=    max(step(u))+1    sg(v)>0   v-->u  sg(u)=0   
            min(step(u))+1    sg(v)=0   v-->u 
[定理]
对于Every-SG 游戏先手必胜当且仅当单一游戏中最大的step的游戏为先手必胜