【【树形背包】】
给一棵树，每个点都有自己的价值，但必须取了这个点的父亲才能取这个点，问最大价值。

这里为方便讲述，树的储存为son[i,j]表示i的第j个儿子，儿子总数为son[i,0]
sc[i]表示i的价值
【nc^2】
f[i,j]表示以i为根的子树中选j个点的最大价值。
先给出程序：
procedure dfs(id:longint);
var
  i,j,k:longint;
begin
  for i:=1 to m do f[id,i]:=sc[id];          //自己一定要学
  for i:=1 to son[id,0] do begin
    dfs(son[id,i]);
    for k:=m downto 1 do                 //01背包DP:把儿子当做物品，一维数组从后往前更新
      for j:=1 to k-1 do                 //用这个儿子中选j个节点去更新自己
        tget(f[son[id,i],j]+f[id,k-j] , f[id,k]);
  end;
end;

【nc】
对于nc^2的过程，我只能说，他太傻了，但是可以借鉴，得到nc做法。
nc^2的做法就像是这样:
第一个儿子的背包                   第二个儿子的背包
                 从左边挑x1个    从右边挑x2个  ----------都是枚举，c^2
                      得到本节点x1+x2的值
事实上这是状态不对，导致不能构建良好的背包模型。
f[i,j]表示访问到i点时所有访问过的点的和i的子树中选j个的最大价值。
这样就等于把上述两个表合并成一列，像普通01背包一样就可以了。
这样就成功借鉴01背包的做法，只是物品的顺序是按访问顺序来的。
可是这样不就是直接做01背包，不是不能保证父亲都有了么？
那我按访问顺序来做时干嘛用的，这样的顺序下来有一步操作就能保证，且看代码：

procedure dfs(id:longint);
var i,k,j:longint;
begin
  if id<>0 then f[id,0]:=-maxlongint;
  for i:=1 to son[id,0] do begin
    for j:=1 to m do
      f[son[id,i],j]:=f[id,j-1]+s[son[id,i]];     //【A】
    dfs(son[id,i]);
    for j:=1 to m do 
      tget(f[son[id,i],j] , f[id,j]);             //【B】
  end;
end;

这里操作A和操作B可以满足很多条件，极其精妙。
首先A是一个放物品的操作，但是可以看到，对于f[son],这个son是必然要放进去的。再看B，这是当前儿子的状态去更新自己，但更好的说法是以父亲为媒介把状态传递给下一个节点。回到A，由于所有的儿子都是以父亲为媒介，以至于不论怎样，儿子的结果中一定有自己。为什么B操作不会让改变父亲一定在的性质呢？枚举到最下面，叶节点一定必取所有祖先，用叶节点去更新父亲，一定是用所有祖先及叶节点必取的状态去更新除了叶节点，所有祖先必取的状态，不论怎么说，做到谁，谁的祖先们都是一定在的，更新只是把不仅祖先必取，自己也取了的结果给父亲，所以保证了父亲节点必取。
此操作类似sap的做法。


注意一定要从dfs(0)开始，因为sc[1]是在dfs(0)的时候加进去的，所以不能省，还能合并多个森林。

注意一定要初始化，起码f[i,0]=-maxlongint;这样才保证必取祖先,但由于超级根0是不取的，所以f[0,0]=0;如果取的是点值不是边值就f[1,0]也是0总之谁不取，谁就是0.
另一种做法是：有1个不取就inc(m)，然后就可以全部变成-maxlongint了。