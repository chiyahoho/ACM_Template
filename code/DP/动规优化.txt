2D/1D问题的状态转移方程可以考虑用四边形不等式优化
就是形如：f[i,j]:=min(f[i,k-1]+f[k,j])+w[i,j](i<k<=j)的方程
但是w[i,j]要是凸的
即对于a<=b<=c<=d，有w[a,c]+w[b,d]<=w[a,d]+w[b,c]
可以把状态转移方程优化为：
f[i,j]:=min(f[i,k-1]+f[k,j])+w[i,j](s[i,j-1]<=i<=s[i+1,j])
其中s[i,j]表示使得f[i,j]取得最优解时的决策变量 

1D/1D

f[i]=min(f[k]+w[k,i])(k<i)
若w数组满足w[i,j]+w[i+1,j+1]<=w[i+1,j]+w[i,j+1]则决策单调
反正要对拍 先写个朴素打出决策表 若发现满足决策单调性则
使用一个栈来维护数据，占中的每一个元素保存一个决策的起始位置与终了位置，显然这些位置相互连接且依次递增。当插入一个新的决策时，从后到前扫描栈，对于每一个老决策来说，做这样两件事：
1、  如果在老决策的起点处还是新决策更好，则退栈，全额抛弃老决策，将其区间合并至新决策中，继续扫描下一个决策。
2、  如果在老决策的起点处是老决策好，则转折点必然在这个老决策的区间中；二分查找之，然后新决策进栈，结束。
由于一个决策出栈之后再也不会进入，所以均摊时间为O(1)，但是由于二分查找的存在，所以整个算法的时间复杂度为O(nlogn)。

上面的转移方程中数组w与当前决策i有关 若能分解成独立于i,k的两个值 就能转换成另一个模型f[i]=min(f[k])+a[i](k<i)
但这是无聊的 只需存一个当前最小值的变量即可 但把可选决策的范围限制就可以用线段树优化到nlogn  若可选决策区间单调就转换成了一个经典模型
f[i]=min(f[k])+a[i](b[i]<=k<c[i]) 对于任意i<j 满足b[i]<=b[j] c[i]<=c[j] 则是典型的单调队列；

f[i]=min(a[i]*x[k]+b[i]*y[k])(k<i)
此模型涵盖甚广
f=ax+by->y=-(a/b)x=f/b  即斜率固定 令纵截距取最值 显然最优决策点在凸包上
1.若斜率与加入的决策点横坐标同时满足单调 则是典型的斜率优化（graham-scan）
(事实上不一定是决策点横坐标单调 有可能是纵坐标/横坐标单调等等 只要满足新添加的点必然添加在两端即可)
2.无任何限制 平衡二叉树维护凸包与查询最优决策（如何删除点？）（编程复杂度高。。）
(需要维护多个凸面的时候 式子稍微变形 就可以只写一个insert和ask 若是初始很多点 只需要删除操作 那么可以转换成逆序添加操作)
