注意每个子过程中p,q的含义，都有可能为父或子。

断线连线的顺序为：下上中

tup中只tget(q)的原因是p还要继续上转。

pass标记下传，tget信息上传。为了得到完整的信息，应当在找点的时候就把标记下传，只有极少数情况下不必，懒得动脑子怕想错就直接下传吧，反正效率几乎相等。而任何一次改变树的结构都要对相应点进行tget,从儿子那里得到新的信息。

pass和tget的原则是处理后信息只读此点即可知晓。

注意在pass过程中，add什么的不仅加到num里，还要加到max。

注意在tget过程中还要先把左右儿子给pass了，因为信息从左右儿子中传出来的。

2种类型的kfnd  (kfnd即select)

2种类型的build

搞出一段区间[x,y],即kfnd到x-1对应的u和y+1对应的v，u转到根，v转到u.r，则此区间就是v.l，打标记什么的像线段树一样对待他。

在x后插入一段区间，就把x转到root,x+1转到root.r,于是root.l.r必然空着，把他们插进去吧。

如果要操作[1,k]或者[k,n]时，会发现没有l-1或r+1,只要自己添加这两个点就可以了，注意添加的两个点的信息也要初始化，不能就0放在那里，要保证不能影响答案，具体看题。

在空间可能不够的情况下，要回收空间，即删掉的部分要用起来。于是把删掉的点的序号存到队列里，新增点不要直接inc(tot),如果队列里有东西就拿出来用。

合并splay:把小的一个个拆下来插到大的里去，看似效率低下，但是把一片森林并成一棵树竟然均摊NlogN。我不会证，但这是事实。