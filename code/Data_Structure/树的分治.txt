对于一个点，边只有经过此点和未经过此点2类。对于未经过的递归处理。经过的通过dfs可以解决。若选取重心求解则满足最多只有logn层，这样效率是nlogn，但dfs后的值需排序，于是n(logn)^2.

做法：
每次用2个dfs(getsize,getroot)找一棵树的重心，标记重心已访问，再从重心开始dfs(getdist)，求出未访问的点到重心的距离，存起来。然后做完了加到答案里。再去dfs(doit)重心切开后剩下子树的。一共4个dfs。
统计时对于未走最短路的路径只需每次一个v出来的先剪掉。