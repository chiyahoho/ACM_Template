将两个堆合并，且合并后仍满足堆的性质，并快速实现堆的功能，这就是可合并堆。

左偏树的原理是不仅满足key值，还要满足dis[lson[a]]<dis[rson[a]]，可以得到最大的左偏树是满二叉树。于是层数小于logn，操作效率是nlogn的。
删除最小(大)的节点：取走树根，并将左右儿子合并。
加入一个点：将一个点与原左偏树合并。

具体请看：左偏树的特点及其应用.doc

随机堆的加入删除等操作与左偏树完全相同，体现在程序上就是就是只有merge函数的不同。
随机堆即randam出0或1，若0则与左儿子并，1则右儿子。由于是基于随机的，层数大约也是logn层，且很难出数据卡掉他。在大多数据下跑的比左偏树快(因为左偏树向左偏的，在右边还空空的时候左边可能已经有达到logn层的链了)，从程序上看也好记一些。



但若需删除其中的某个点(非最大最小点)：
左偏树，删除P且将左右儿子合并，得到新的子树。此时再不断向上调整。调整伪代码：
while q ≠ NULL do
    If dist(left(q)) < dist(right(q)) Then
        swap(left(q), right(q))
    If dist(right(q))+1 = dist(q) Then
        Exit Procedure
    dist(q) ← dist(right(q))+1
    p ← q
    q ← parent(q)
End

对于随机堆就更方便了，将左右儿子合并来替代p即可。