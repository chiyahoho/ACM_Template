本质是树的分治。
size[u]=以u为根的子树的节点个数。令v为u的儿子中Size最大的一个，则边[u→v]为重边，其余边为轻边。
重路径：全部由重边组成的路径。
易证：每个点到根的路径上不超过logN条轻边和logN条重路径。
对于每条重路径，建立一棵线段树，可以用logN的时间求解。对于轻边直接处理。

【问题一】：需要维护的信息。
用2个dfs维护出以下信息：
fa[u]:u的父亲
deep[u]:u的深度
sz[u]:以u为根的子树节点个数

bel[u]:u属于哪条重路径
po[u]:u在所在重路径中的位置
hd[u]:u所在重路径的头
lh[hd[u]]:u所在重路径的尾在重路径中的位置

接着建立线段树并维护以下答案信息：
ma[nod]:tr[nod]这条链中的最大值
sum[nod]:链的和
⋯⋯还有很多看题目而定

【问题二】：如何简便的建立多棵线段树。
利用这些信息去建立很多线段树，如果将线段树们放到一个数组里维护，代码会简短很多。这样insert的时候就不是像普通线段树一样从1开始，而是从bel[u]开始，后面都相同，inc(path),然后tr[path]就是原先的一半什么的，都跟普通线段树一样处理，就是开始不从1开始。

【问题三】：如何找到x到y的路径。
普通法：查询x→lca(x,y)和y→lca(x,y)分别的答案，再合并。查询的方法是看hd[x]与hd[lca(x,y)]相等了没有，没有的话就查询整段线段树tr[bel[x]],再x=fa[hd[x]];相等了就只查那一段。
优化版：发现可以不用可以求lca就找到lca。做法是把x,y像上述方法一样不断往上提，但不是提到lca，而是hd谁矮提谁，最后必然会到同一条链上，并且高的那个就是lca。此部分看代码更易理解。

【问题四】：当权值在边上时，轻边不在线段树里怎么判。
只需要在每次一条重路径查完时看看重路径的头与其父亲的连边即可。